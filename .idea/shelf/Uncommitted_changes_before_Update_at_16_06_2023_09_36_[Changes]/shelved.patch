Index: installation/game.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import math\r\nimport time\r\nimport random\r\nimport openai\r\nimport json\r\nimport os\r\nfrom dotenv import load_dotenv\r\nfrom pythonosc import udp_client\r\nfrom pythonosc import osc_server\r\nfrom pythonosc.dispatcher import Dispatcher\r\nfrom threading import Thread\r\nimport socket\r\n\r\n\r\n# Loads in .env file which needs to be located in the same folder as this file\r\nload_dotenv()\r\n# Fetches api key from .env file (can be generated at https://platform.openai.com/account/api-keys)\r\nopenai.api_key = os.getenv(\"OPENAI_API_KEY\")\r\n\r\n# client für export zu touchdesigner\r\nclient = udp_client.SimpleUDPClient(\"127.0.0.1\", 7000)\r\n\r\n# Copied from: https://www.w3resource.com/python-exercises/python-basic-exercise-55.php\r\n# Gets current ip address of pc\r\nip_address = [l for l in ([ip for ip in socket.gethostbyname_ex(socket.gethostname())[2]\r\n                           if not ip.startswith(\"127.\")][:1], [[(s.connect(('8.8.8.8', 53)),\r\n                                                                 s.getsockname()[0], s.close()) for s in\r\n                                                                [socket.socket(socket.AF_INET,\r\n                                                                               socket.SOCK_DGRAM)]][0][1]]) if l][0][0]\r\n\r\nclass Catastrophe:\r\n    def __init__(self):\r\n        self.type = 'hurricane'\r\n        self.duration = 100\r\n        self.wind_up = 10\r\n        self.deaths_per_second = 10\r\n\r\nclass Symptoms:\r\n    def __init__(self):\r\n        # Start values\r\n        self.prompt = \"Generiere 25 kurze, fiktive & sarkastische Schlagzeilen über den Klimawandel. Die Schlagzeilen sollen keine Jahreszahlen oder den Begriff Klimawandel beinhalten. Geb die Schlagzeilen als Liste mit dem key 'headlines' in einer JSON zurück\"\r\n        self.is_game_running = True\r\n        self.start_year = 2025\r\n        self.year = self.start_year\r\n        self.count = 0\r\n        self.death_count = 0\r\n        self.temperature = 1\r\n        self.free_regions = (\"na1\", \"na2\", \"eu1\", \"eu2\", \"sa1\", \"sa2\", \"me1\", \"af1\", \"af2\", \"as1\", \"as2\", \"oc1\")\r\n        self.occupied_regions = set()\r\n        self.region_data = {\r\n            \"na1\": {\r\n                \"is_active\": False,\r\n                \"type\": None,\r\n                \"duration\": None,\r\n                \"wind_up\": None,\r\n                \"deaths_per_second\": None,\r\n                \"resolution_time\": None,\r\n            },\r\n        }\r\n        self.headlines = []\r\n        self.sensor_values = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\r\n        self.is_test_event_active = False\r\n\r\n    def get_inputs(self):\r\n        # Writes sensor input from Pi Cap into variable\r\n        def get_diff_values(unused_addr, *args):\r\n            self.sensor_values = args\r\n\r\n        # Maps dispatcher to path of diff values\r\n        dispatcher = Dispatcher()\r\n        dispatcher.map(\"/diff*\", get_diff_values)\r\n\r\n        # Initiates OSC server\r\n        server = osc_server.BlockingOSCUDPServer((ip_address, 3000), dispatcher)\r\n        server.serve_forever()\r\n\r\n    def generate_headlines(self, verbose):\r\n        while True:\r\n            if len(self.headlines) < 100:\r\n                if verbose:\r\n                    print(\"Filling up headlines... (currently \" + str(len(self.headlines)) + \"/100)\")\r\n                # Calls GPT API and requests headlines\r\n                gpt_response = openai.ChatCompletion.create(\r\n                    model=\"gpt-3.5-turbo\",\r\n                    messages=[\r\n                        {\"role\": \"user\",\r\n                         \"content\": self.prompt}\r\n                    ]\r\n                )\r\n                try:\r\n                    # Converts response into JSON\r\n                    headlines_json = json.loads(gpt_response.choices[0].message.content)\r\n                    # Adds new headlines to headlines array\r\n                    for headline in headlines_json['headlines']:\r\n                        self.headlines.append(headline)\r\n                    # Rests for 5 seconds\r\n                    time.sleep(5)\r\n                except Exception:\r\n                    # Catches wrong response from GPT API\r\n                    print('GPT returned wrong data format')\r\n\r\n    def get_temperature(self):\r\n        # Temperature graph\r\n        self.temperature = 1.5 * math.cos(0.04 * (self.year - self.start_year) + math.pi) + 2.5\r\n        print(self.temperature)\r\n        # Sendet Temperatur an Textfile\r\n        speichern_news(\"/temperature/\", self.temperature)\r\n\r\n    def trigger_headline(self):\r\n        if len(self.headlines) > 0:\r\n            # Randomly picks headline from array\r\n            index = random.randrange(0, len(self.headlines))\r\n            print(self.headlines[index])\r\n            # Sendet Headline an Textfile\r\n            speichern_news(\"/headline/\", self.headlines[index])\r\n            # Removes chosen headline from array\r\n            del self.headlines[index]\r\n        else:\r\n            print(\"--- Blank (headline) ---\")\r\n            #Später löschen\r\n            speichern_news(\"/headline/\", \"nix\")\r\n\r\n    def trigger_catastrophe(self):\r\n        # TODO: Proper catastrophe logic\r\n        self.is_test_event_active = True\r\n        catastrophes = ['drought', 'hurricane', 'flood', 'wildfire', 'sandstorm']\r\n        catastrophe = random.choice(catastrophes)\r\n        print(f'Oh no! A {catastrophe}  ＼(º □ º l|l)/')\r\n        # Sendet Katastrophe an Textfile\r\n        speichern_news(\"/catastrophe/\", catastrophe)\r\n        while self.sensor_values[0] < 100:\r\n            time.sleep(0.01)\r\n        print(f'{catastrophe} resolved.')\r\n        time.sleep(2)\r\n        self.is_test_event_active = False\r\n\r\n    def trigger_event(self):\r\n        # Chance of headline occurring\r\n        chance_headline = 0.25\r\n        # Base chance of catastrophe occurring\r\n        base_chance_catastrophe = 0.10\r\n        # Temperature increase since game start\r\n        temperature_delta = self.temperature - 1\r\n        # Chance of nothing happening\r\n        chance_remaining = 1 - chance_headline - base_chance_catastrophe\r\n        # Chance of catastrophe occurring depending on temperature\r\n        chance_catastrophe = base_chance_catastrophe + (\r\n                math.cos(math.pi + (temperature_delta / 3) * math.pi) + 1) * chance_remaining\r\n\r\n        # Picks random number\r\n        random_number = random.randrange(0, 101) / 100\r\n\r\n        # Triggers headline\r\n        if random_number < chance_headline:\r\n            self.trigger_headline()\r\n        # Triggers catastrophe\r\n        elif random_number < (chance_headline + chance_catastrophe):\r\n            if not self.is_test_event_active:\r\n                Thread(target=self.trigger_catastrophe).start()\r\n            else:\r\n                # Triggers nothing if all regions are occupied\r\n                print(\"--- Blank (catastrophe) ---\")\r\n                #Später löschen\r\n                speichern_news(\"/catastrophe/\", \"nix\")\r\n        # Triggers nothing\r\n        else:\r\n            print(\"--- Blank ---\")\r\n            #Später löschen\r\n            speichern_news(\"/catastrophe/\", \"nix\")\r\n    def run(self, skip_headlines):\r\n        # Waits for headline generation until at least 20 are available\r\n        if len(self.headlines) < 20 and not skip_headlines:\r\n            print(\"Waiting for headlines...\")\r\n        while len(self.headlines) < 20 and not skip_headlines:\r\n            pass\r\n\r\n        # Main game loop\r\n        while self.year < 2100:\r\n            self.trigger_event()\r\n            self.count += 1\r\n            if self.count == 5:\r\n                self.year += 1\r\n                print(self.year)\r\n                speichern_news(\"/year/\", self.year)\r\n                self.count = 0\r\n                self.get_temperature()\r\n            time.sleep(1)\r\n        # TODO: logic for starting & ending game\r\n        self.is_game_running = False\r\n    \r\n    def main(self, skip_headlines=True, verbose=True):\r\n        # headline generation thread\r\n        if not skip_headlines:\r\n            Thread(target=self.generate_headlines, args=(verbose,)).start()\r\n\r\n        # runtime thread\r\n        Thread(target=self.run, args=(skip_headlines,)).start()\r\n\r\n        # input fetching thread\r\n        Thread(target=self.get_inputs(), daemon=True).start()\r\n\r\n#Speichert alle News für die GUI in news.txt\r\ndef speichern_news(type , value):\r\n    with open(\"news.txt\", 'a') as datei: \r\n        datei.write(type + str(value) + '\\n')\r\n\r\nsymptoms = Symptoms()\r\n\r\n# Props:\r\n# skip_headlines: Whether headline generation is skipped (defaults to False)\r\n# verbose: Prints progress of headline generation (defaults to True)\r\nsymptoms.main(skip_headlines=True, verbose=True)
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/installation/game.py b/installation/game.py
--- a/installation/game.py	(revision 7fb75d2ab512eee04b235702faea6bc9d26c7835)
+++ b/installation/game.py	(date 1686566588144)
@@ -135,6 +135,7 @@
         self.is_test_event_active = False
 
     def trigger_event(self):
+        client.send_message("/catastrophes", [100, 200])
         # Chance of headline occurring
         chance_headline = 0.25
         # Base chance of catastrophe occurring
